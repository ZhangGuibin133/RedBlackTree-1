# RedBlackTree-1
红黑树
我觉得方向判断太多,结构不够清晰,你看一下我的思路,供你参考,基本上一个函数即可解决

2.	子为父:一个顶点被子节点替换,如何处理,可保证树形不变,想象滑轮
a.	欲为父,必交其子代位,变更三条线,祖级孙级及相互关系
b.	红黑影响三条线,兄弟树,一个Near树(离父近)一个Far树(离父远)
c.	兄弟树原父->父+子),Far子+父->子,Near子+父->父+子(总不变不再考虑)
d.	如果两个总是交换颜色,兄弟树不变总多子色,Far树子+父->父,少一个子色
e.	红变化,红子代父,整体黑不变 
f.	黑变化,兄弟树多一黑,Far子树少一黑,Far为红置黑后黑不变,用于删除
g.	Near树与父相连,如父级颜色不能确定,需要考虑不能为红,否则可能红红相连,此时可分两步走,先用Near代子,Near再代父
h.	以上交换按其键值或相互关系判断,一个函数实现即可(总是交换颜色)
i.	关键就是交换时必须交换颜色,后面的就只是调用该函数了

3.	增加节点 
a.	增加节点必为红,按其键值找到父节点
b.	递归出口:父节点为空,设为根,变黑
c.	递归出口:父节点为黑,满足红黑要求
d.	递归出口:父节点为红,键值如果在祖及父中间,先替父,再替祖
e.	递归出口:父节点为红,不在祖及父中间,父替祖
f.	父节点为红,叔叔为红,则将父与叔叔变黑,将祖节点变红,由祖节点递归

4.	删除节点
a.	删除时,先找替代,其替代必为其最靠近的点,右子的最左,或左子的最右,任选一个即可,以下选右边最近的点
b.	替代可能有右子为红,将右子进位,可将替代变红
c.	替代可能为自身,此时可能左子为红,将此子进位,替代变红
d.	删除时,如替代为红,直接删除

5.	黑子删除 需要本通道增加一黑,兄弟通道黑不变
a.	递归出口:为根
b.	递归出口:不为根必有兄弟,如近侄为红,先替兄,再替父,将红子变黑
c.	递归出口:远侄为红,兄替父,红变黑,黑不变
d.	递归出口:如父为红,将父变黑,兄弟变红(兄弟无红子,满足红黑条件)
e.	如兄弟为红,用兄弟代父,红黑不变,再递归检查,等于检查兄弟过来的子树,总有出口
f.	全黑,将兄弟变红,兄弟树也减少一黑,用父递归

6.	将替代断开连接,并替换删除目标,复制其颜色即可,以上均要进行根检查
